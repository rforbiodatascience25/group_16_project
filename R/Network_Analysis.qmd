---
title: "Network Analysis"
format: html
---

# Load Libraries

```{r}
#| message: false
library("GEOquery")
library("Biobase")
library("limma")
library("dplyr")
library("tibble")
library("stringr")
library("readr")
library("igraph")
library("msigdbr")
library("clusterProfiler")
library("Matrix")
library("quarto")
```

# Load Data

```{r}
expr_data <- read.csv(
  "../data/GSE45827_clean_expression.csv",
  row.names = 1
)

feature_data <- read.csv(
  "../data/GSE45827_clean_Feature_metadata.csv"
)
names(feature_data)[1] <- "ProbeID"


pheno_data <- read.csv(
  "../data/GSE45827_clean_Phenotype_metadata.csv",
)
names(pheno_data)[1] <- "SampleID"
```

**Set output directory**

```{r}
output_dir <- "../results"
```

# Differential Expression Analysis

Analysis is performed using limma. It involves a linear model that is fitted for the Tumor vs Normal contrast and empirical Bayes shrinkage which is applied to stabilize variance estimates. All tested genes are carried forward to the network analysis, while significantly differentiated ones (e.g. FDR \< 0.05 and \|logFC\| \> 1) are later used as seed genes to anchor subnetworks.

**Set up Model**

```{r}
design_all <- model.matrix(
  ~ diagnosis,
  data = pheno_data
)
```

**Fit model**

```{r}
fit_all <- expr_data |>
  lmFit(design_all) |>
  eBayes()
```

**Get Results**

```{r}
tt_tumor_vs_normal <- topTable(
  fit_all,
  coef   = "diagnosisHealthy",
  number = Inf,
  sort.by = "P"
)
head(tt_tumor_vs_normal)
```

**View Differential Expression Results**

```{r}
tt_tumor_vs_normal <- tt_tumor_vs_normal |>
  rownames_to_column("ProbeID") |>
  left_join(
    feature_data |>
      select(
        ProbeID,
        Gene.Symbol = `Gene.Symbol`
      ),
    by = "ProbeID"
  ) |>
  relocate(Gene.Symbol, .after = ProbeID)

head(tt_tumor_vs_normal)
```

**Number of significant genes (FDR\<0.05, \|logFC\|\>1):**

```{r}
sum(
    tt_tumor_vs_normal$adj.P.Val < 0.05 &
    abs(tt_tumor_vs_normal$logFC) > 1
)
```

**Save Results**

```{r}
DE_results <- list(
  Tumor_vs_Normal = tt_tumor_vs_normal
)
```

# Network Analysis

**Load Helper Functions**

```{r}
source("99_proj_func.R")
```

## Network Construction and Summary

We construct a Reactome co-membership network using geneâ€“pathway incidence data. The edges reflect shared pathway membership and seed genes serve as anchors for selecting relevant subnetworks. After Louvain community detection, we extract the largest connected clusters and compute core network statistics including modules, hubs, and connectivity.

```{r}
tag <- "Tumor_vs_Normal"

tt_gene <- collapse_to_genes(
  DE_results[[tag]],
  feature_data
)

universe_symbols <- tt_gene$symbol
head(universe_symbols)
```

```{r}
sym2 <- tt_gene |>
  select(
    symbol,
    logFC,
    adj.P.Val
  ) |>
  distinct()
head(sym2)
```

```{r}
seeds <- pick_seeds(
  tt_gene,
  fdr = 0.01,
  lfc = 1.5
)
head(seeds)
```

**Universe genes:**

```{r}
length(universe_symbols)
```

**Seed genes:**

```{r}
length(seeds)
```

```{r}
reactome_df <- msigdbr(
  species = "Homo sapiens",
  category = "C2",
  subcategory = "REACTOME"
) |>
  select(
    gs_name,
    gene_symbol
  ) |>
  distinct() |>
  filter(
    gene_symbol %in% universe_symbols
  )
head(reactome_df)
```

**Reactome pathways covering universe:**

```{r}
length(unique(reactome_df$gs_name))
```

```{r}
genes <- sort(unique(reactome_df$gene_symbol))
paths <- sort(unique(reactome_df$gs_name))

gi <- match(reactome_df$gene_symbol, genes)
pi <- match(reactome_df$gs_name, paths)
```

**Make Adjacency Matrix**

```{r}
Inc <- sparseMatrix(
  i = gi,
  j = pi,
  x = 1,
  dims = c(length(genes), length(paths)),
  dimnames = list(genes, paths)
)

Adj <- Inc %*% t(Inc)
diag(Adj) <- 0

min_shared <- 2

seed_idx <- which(rownames(Adj) %in% seeds)
nbr_raw <- Adj[seed_idx, , drop = FALSE] > 0

if (length(seed_idx) == 1) {
  nbr_idx <- which(as.vector(nbr_raw))
} else {
  nbr_idx <- unique(
    unlist(
      apply(
        nbr_raw,
        1,
        which
      )
    )
  )
}

nbr_idx <- unique(c(seed_idx, nbr_idx))

Adj_sub <- Adj[nbr_idx, nbr_idx, drop = FALSE]

A <- summary(Adj_sub)

A <- A[
  A$i < A$j & A$x >= min_shared,
  ,
  drop = FALSE
]

```

**Define Edges**

```{r}
edges <- tibble(
  from = rownames(Adj_sub)[A$i],
  to = rownames(Adj_sub)[A$j],
  weight = as.numeric(A$x)
)
```

**Define Vertices**

```{r}
node_syms <- sort(unique(c(edges$from, edges$to)))
```

**Define Graph**

```{r}
g <- graph_from_data_frame(
  d = edges,
  vertices = tibble(symbol = node_syms),
  directed = FALSE
)

V(g)$symbol <- V(g)$name
V(g)$seed <- V(g)$symbol %in% seeds

V(g)$logFC <- sym2$logFC[
  match(V(g)$symbol, sym2$symbol)
]

V(g)$adj.P.Val <- sym2$adj.P.Val[
  match(V(g)$symbol, sym2$symbol)
]

g <- igraph::simplify(
  g,
  remove.multiple = TRUE,
  remove.loops = TRUE,
  edge.attr.comb = list(weight = "sum")
)
```

**Get Clusters**

```{r}
com <- cluster_louvain(
  g,
  weights = E(g)$weight
)

V(g)$module <- membership(com)

comp <- components(g)
gc_id <- which.max(comp$csize)

g <- induced_subgraph(
  g,
  vids = which(comp$membership == gc_id)
)
```

**Final network - Nodes:**

```{r}
gorder(g)
```

**Edges:**

```{r}
gsize(g)
```

**Modules detected:**

```{r}
length(unique(V(g)$module))
```

```{r}
plot_net_modules_hubs(
  g,
  tag,
  output_dir
)
```

```{r}
hub_logical <- get_hub_logical(g, q = 0.90)
head(hub_logical)
```

```{r}
nodes_out <- tibble(
  symbol = V(g)$symbol,
  hub = hub_logical,
  seed = V(g)$seed,
  module = V(g)$module,
  degree = degree(g),
  strength = strength(
    g,
    vids = V(g),
    weights = E(g)$weight
  ),
  betweenness = betweenness(
    g,
    directed = FALSE,
    normalized = TRUE
  ),
  logFC = V(g)$logFC,
  adj.P.Val = V(g)$adj.P.Val
)

head(nodes_out)
```

```{r}
mod_DE_info <- nodes_out |>
  group_by(module) |>
  summarise(
    module_size = n(),
    n_DE = sum(
      adj.P.Val < 0.05,
      na.rm = TRUE
    ),
    .groups = "drop"
  )
head(mod_DE_info)
```

**Network Statistics:**

**Total nodes:**

```{r}
gorder(g)
```

**Total edges:**

```{r}
gsize(g)
```

**Seed nodes:**

```{r}
sum(V(g)$seed)
```

**Modules:**

```{r}
length(unique(V(g)$module))
```

**Density:**

```{r}
edge_density(g)
```

**Transitivity:**

```{r}
transitivity(g)
```

## Over-Representation Analysis (ORA)

To biologically interpret the network modules, we perform Reactome over-representation analysis. For each module, the most significantly enriched pathway is used as a representative label. This links graph-based communities to biological processes.

```{r}
reactome_t2g <- msigdbr(
  species = "Homo sapiens",
  category = "C2",
  subcategory = "REACTOME"
) |>
  select(
    term = gs_name,
    gene = entrez_gene
  ) |>
  distinct()
head(reactome_t2g)
```

```{r}
mods <- sort(unique(V(g)$module))
ora_results <- vector("list", length(mods))
names(ora_results) <- paste0("Module_", mods)
```

```{r}
for (i in seq_along(mods)) {
  m <- mods[i]

  mod_genes <- nodes_out$symbol[
    nodes_out$module == m
  ]
  
  res <- enrich_module(
    genes_symbol = mod_genes,
    universe_symbol = universe_symbols,
    tag = tag,
    mod_id = m,
    output_dir = "."
  )
  
  ora_results[[i]] <- res
}
ora_results
```

```{r}
module_enrich_df <- bind_rows(
  lapply(
    seq_along(ora_results),
    function(i) {
      res <- ora_results[[i]]

      if (is.null(res)) {
        return(NULL)
      }

      df <- as.data.frame(res)

      if (nrow(df) == 0) {
        return(NULL)
      }

      df$module <- mods[i]
      df
    }
  )
)

head(module_enrich_df)
```

```{r}
module_summary <- module_enrich_df |>
  group_by(module) |>
  summarise(
    n_sig_pathways = n(),
    top_term = ID[which.min(p.adjust)],
    top_q = min(p.adjust),
    .groups = "drop"
  )

module_summary <- module_summary |>
  left_join(
    mod_DE_info,
    by = "module"
  ) |>
  arrange(top_q)

module_summary <- module_summary |>
  mutate(
    module_label = str_replace_all(
      top_term,
      "^REACTOME_",
      ""
    ),
    module_label = str_replace_all(
      module_label,
      "_",
      " "
    )
  )

head(module_summary)
```

```{r}
key_modules <- module_summary |>
  filter(
    n_sig_pathways >= 2,
    top_q < 0.05,
    n_DE >= 3
  ) |>
  arrange(top_q)

key_modules |>
  select(
    module,
    module_size,
    n_sig_pathways,
    top_q
  )
head(key_modules)
```

```{r}
nodes_out <- nodes_out |>
  left_join(
    module_summary |>
      select(module, module_label),
    by = "module"
  )

nodes_out <- nodes_out |>
  mutate(
    in_key_module = module %in% key_modules$module
  ) |>
  relocate(in_key_module, .after = module)
head(nodes_out)
```

**Save Results**

```{r}
write_csv(
  key_modules,
  file.path(
    output_dir,
    paste0(tag, "_key_modules_ranked.csv")
  )
)
```

## Extraction of Key Differentially Expressed Genes

From the annotated network, we extract the top 20 upregulated and top 20 downregulated genes. These represent highly differentiated genes in the Tumor vs Normal contrast and are used for summarizing key biological processes in the data.

```{r}
top20_up <- nodes_out |>
  filter(
    !is.na(logFC),
    logFC > 0,
    !is.na(adj.P.Val),
    adj.P.Val < 0.05
  ) |>
  arrange(desc(logFC)) |>
  slice_head(n = 20) |>
  mutate(direction = "Upregulated")

head(top20_up)
```

```{r}
top20_down <- nodes_out |>
  filter(
    !is.na(logFC),
    logFC < 0,
    !is.na(adj.P.Val),
    adj.P.Val < 0.05
  ) |>
  arrange(logFC) |>
  slice_head(n = 20) |>
  mutate(direction = "Downregulated")

head(top20_down)
```

```{r}
combined_40 <- bind_rows(
  top20_up,
  top20_down
) |>
  arrange(
    desc(abs(logFC))
  )

head(combined_40)
```

**Save Resilts**

```{r}
write_csv(
  combined_40,
  file.path(
    output_dir,
    paste0(tag, "_top40_DE.csv")
  )
)
```
