---
title: "Network_Analysis"
format: html
---

# 1. Loading Libraries

```{r}
suppressPackageStartupMessages({
  library("GEOquery")
  library("Biobase")
  library("limma")
  library("dplyr")
  library("tibble")
  library("stringr")
  library("readr")
  library("igraph")
  library("msigdbr")
  library("clusterProfiler")
  library("Matrix")
})
```

# 2. Importing Data

```{r}
expr_data <- read.csv(
  "../data/GSE45827_clean_expression.csv",
  row.names = 1
)

feature_data <- read.csv(
  "../data/GSE45827_clean_Feature_metadata.csv",
  row.names = 1
)

pheno_data <- read.csv(
  "../data/GSE45827_clean_Phenotype_metadata.csv",
  row.names = 1
)
```

# 3. Output Directory

```{r}
output_dir <- "../results"
```

# 4. Data Wrangling for DE Analysis

We prepare the phenotype and expression matrices for DE analysis. This mainly includes standardizing sample identifiers, defining the binary Tumor/Normal group variable and aligning phenotype rows with expression columns.

```{r}
pheno_data <- pheno_data |>
  as.data.frame() |>
  tibble::rownames_to_column("SampleID") |>
  dplyr::mutate(
    group = dplyr::if_else(
      diagnosis == "Healthy",
      "Normal",
      "Tumor"
    )
  ) |>
  dplyr::select(
    SampleID,
    group,
    subtype
  ) |>
  dplyr::filter(!is.na(group))

expr_clean <- expr_data[
  ,
  pheno_data$SampleID,
  drop = FALSE
]

stopifnot(
  all(
    colnames(expr_clean) %in% pheno_data$SampleID
  )
)

pheno_data <- pheno_data[
  match(colnames(expr_clean), pheno_data$SampleID),
]

expr_data <- expr_clean

feature_data <- feature_data |>
  as.data.frame() |>
  tibble::rownames_to_column("ProbeID")

ph_all <- pheno_data |>
  dplyr::mutate(
    group = factor(
      group,
      levels = c("Normal", "Tumor")
    )
  )

design_all <- model.matrix(
  ~ group,
  data = ph_all
)
```

# 5. Differential Expression Analysis

Analysis is performed using limma. It involves a linear model that is fitted for the Tumor vs Normal contrast and empirical Bayes shrinkage which is applied to stabilize variance estimates. All tested genes are carried forward to the network analysis, while significantly differentiated ones (e.g. FDR < 0.05 and |logFC| > 1) are later used as seed genes to anchor subnetworks.

```{r}
fit_all <- expr_data |>
  lmFit(design_all) |>
  eBayes()

tt_tumor_vs_normal <- topTable(
  fit_all,
  coef   = "groupTumor",
  number = Inf,
  sort.by = "P"
)

tt_tumor_vs_normal <- tt_tumor_vs_normal |>
  tibble::rownames_to_column("ProbeID") |>
  dplyr::left_join(
    feature_data |>
      dplyr::select(
        ProbeID,
        Gene.Symbol = `Gene.Symbol`
      ),
    by = "ProbeID"
  ) |>
  dplyr::relocate(Gene.Symbol, .after = ProbeID)

cat(
  "DE analysis is completed. ",
  "Number of significant genes (FDR<0.05, |logFC|>1): ",
  sum(
    tt_tumor_vs_normal$adj.P.Val < 0.05 &
      abs(tt_tumor_vs_normal$logFC) > 1
  ),
  "\n"
)

DE_results <- list(
  Tumor_vs_Normal = tt_tumor_vs_normal
)
```

# 6. Network Analysis

## 6.1 Helper Functions

We define a set of helper functions for collapsing multiple probes to gene-level statistics, selecting seed genes, identifying hubs, and visualizing network modules.

```{r}
collapse_to_genes <- function(tt, feature_tbl) {
  tt <- tt |>
    tibble::as_tibble()

  feature_tbl <- feature_tbl |>
    tibble::as_tibble()

  tt |>
    dplyr::select(
      ProbeID,
      logFC,
      t,
      P.Value,
      adj.P.Val
    ) |>
    dplyr::left_join(
      feature_tbl |>
        dplyr::select(
          ProbeID,
          Gene.Symbol = `Gene.Symbol`,
          ENTREZ_GENE_ID
        ),
      by = "ProbeID"
    ) |>
    dplyr::filter(
      !is.na(Gene.Symbol),
      Gene.Symbol != ""
    ) |>
    dplyr::group_by(Gene.Symbol) |>
    dplyr::slice_min(
      order_by = adj.P.Val,
      n = 1,
      with_ties = FALSE
    ) |>
    dplyr::ungroup() |>
    dplyr::rename(
      symbol = Gene.Symbol,
      entrez = ENTREZ_GENE_ID
    )
}

pick_seeds <- function(
  tt_gene,
  fdr = 0.01,
  lfc = 1.5,
  top_n = NULL
) {
  seeds <- tt_gene |>
    dplyr::filter(
      adj.P.Val < fdr,
      abs(logFC) >= lfc
    ) |>
    dplyr::arrange(adj.P.Val) |>
    dplyr::pull(symbol) |>
    unique()

  if (!is.null(top_n)) {
    seeds <- head(seeds, top_n)
  }

  seeds
}

get_hub_logical <- function(g, q = 0.90) {
  deg <- igraph::degree(g)
  thr <- stats::quantile(
    deg,
    probs = q,
    na.rm = TRUE
  )
  deg >= thr
}

plot_net_modules_hubs <- function(
  g,
  tag,
  output_dir,
  lay = NULL
) {
  if (is.null(lay)) {
    set.seed(1)
    lay <- igraph::layout_with_fr(g)
  }

  deg <- igraph::degree(g)
  deg_min <- min(deg)
  deg_max <- max(deg)

  if (deg_max > deg_min) {
    igraph::V(g)$size <- 4 +
      14 * (deg - deg_min) / (deg_max - deg_min)
  } else {
    igraph::V(g)$size <- 8
  }

  modules <- sort(unique(igraph::V(g)$module))
  pal <- grDevices::rainbow(length(modules))

  igraph::V(g)$color <- pal[
    match(igraph::V(g)$module, modules)
  ]

  hubs <- get_hub_logical(g, q = 0.90)
  igraph::V(g)$frame.color <- ifelse(
    hubs,
    "black",
    NA
  )

  ew <- igraph::E(g)$weight
  ew_min <- min(ew)
  ew_max <- max(ew)

  if (ew_max > ew_min) {
    igraph::E(g)$width <- 0.5 +
      2.5 * (ew - ew_min) / (ew_max - ew_min)
  } else {
    igraph::E(g)$width <- 1
  }

  igraph::E(g)$color <- "grey80"

  out_file <- file.path(
    output_dir,
    paste0(
      tag,
      "_network_modules.png"
    )
  )

  grDevices::png(
    out_file,
    width = 1400,
    height = 1000,
    res = 130,
    type = "cairo"
  )

  plot(
    g,
    layout = lay,
    vertex.label = NA,
    main = paste0(
      tag,
      " Reactome co-membership network (modules & hubs)"
    )
  )

  graphics::legend(
    "topleft",
    legend = paste("Module", modules),
    col = pal,
    pch = 16,
    bty = "n",
    cex = 0.8
  )

  graphics::legend(
    "bottomleft",
    legend = c("Hubs (top 10% degree)"),
    pch = 21,
    pt.bg = "white",
    col = "black",
    bty = "n",
    cex = 0.8
  )

  grDevices::dev.off()
}
```

## 6.2 Network Construction and Summary

We construct a Reactome co-membership network using geneâ€“pathway incidence data. The edges reflect shared pathway membership and seed genes serve as anchors for selecting relevant subnetworks. After Louvain community detection, we extract the largest connected clusters and compute core network statistics including modules, hubs, and connectivity.

```{r}
tag <- "Tumor_vs_Normal"

tt_gene <- collapse_to_genes(
  DE_results[[tag]],
  feature_data
)

universe_symbols <- tt_gene$symbol

seeds <- pick_seeds(
  tt_gene,
  fdr = 0.01,
  lfc = 1.5
)

cat("Universe genes:", length(universe_symbols), "\n")
cat("Seed genes:", length(seeds), "\n")

reactome_df <- msigdbr(
  species = "Homo sapiens",
  category = "C2",
  subcategory = "REACTOME"
) |>
  dplyr::select(
    gs_name,
    gene_symbol
  ) |>
  dplyr::distinct() |>
  dplyr::filter(
    gene_symbol %in% universe_symbols
  )

cat(
  "Reactome pathways covering universe:",
  length(unique(reactome_df$gs_name)),
  "\n"
)

genes <- sort(unique(reactome_df$gene_symbol))
paths <- sort(unique(reactome_df$gs_name))

gi <- match(reactome_df$gene_symbol, genes)
pi <- match(reactome_df$gs_name, paths)

Inc <- Matrix::sparseMatrix(
  i = gi,
  j = pi,
  x = 1,
  dims = c(length(genes), length(paths)),
  dimnames = list(genes, paths)
)

Adj <- Inc %*% Matrix::t(Inc)
diag(Adj) <- 0

min_shared <- 2

seed_idx <- which(rownames(Adj) %in% seeds)
nbr_raw <- Adj[seed_idx, , drop = FALSE] > 0

if (length(seed_idx) == 1) {
  nbr_idx <- which(as.vector(nbr_raw))
} else {
  nbr_idx <- unique(
    unlist(
      apply(
        nbr_raw,
        1,
        which
      )
    )
  )
}

nbr_idx <- unique(c(seed_idx, nbr_idx))

Adj_sub <- Adj[nbr_idx, nbr_idx, drop = FALSE]

A <- summary(Adj_sub)

A <- A[
  A$i < A$j & A$x >= min_shared,
  ,
  drop = FALSE
]

edges <- tibble::tibble(
  from = rownames(Adj_sub)[A$i],
  to = rownames(Adj_sub)[A$j],
  weight = as.numeric(A$x)
)

node_syms <- sort(unique(c(edges$from, edges$to)))

g <- igraph::graph_from_data_frame(
  d = edges,
  vertices = tibble::tibble(symbol = node_syms),
  directed = FALSE
)

sym2 <- tt_gene |>
  dplyr::select(
    symbol,
    logFC,
    adj.P.Val
  ) |>
  dplyr::distinct()

igraph::V(g)$symbol <- igraph::V(g)$name
igraph::V(g)$seed <- igraph::V(g)$symbol %in% seeds

igraph::V(g)$logFC <- sym2$logFC[
  match(igraph::V(g)$symbol, sym2$symbol)
]

igraph::V(g)$adj.P.Val <- sym2$adj.P.Val[
  match(igraph::V(g)$symbol, sym2$symbol)
]

g <- igraph::simplify(
  g,
  remove.multiple = TRUE,
  remove.loops = TRUE,
  edge.attr.comb = list(weight = "sum")
)

com <- igraph::cluster_louvain(
  g,
  weights = igraph::E(g)$weight
)

igraph::V(g)$module <- igraph::membership(com)

comp <- igraph::components(g)
gc_id <- which.max(comp$csize)

g <- igraph::induced_subgraph(
  g,
  vids = which(comp$membership == gc_id)
)

cat("Final network - Nodes:", igraph::gorder(g), "\n")
cat("Edges:", igraph::gsize(g), "\n")
cat(
  "Modules detected:",
  length(unique(igraph::V(g)$module)),
  "\n"
)

plot_net_modules_hubs(
  g,
  tag,
  output_dir
)

hub_logical <- get_hub_logical(g, q = 0.90)

nodes_out <- tibble::tibble(
  symbol = igraph::V(g)$symbol,
  hub = hub_logical,
  seed = igraph::V(g)$seed,
  module = igraph::V(g)$module,
  degree = igraph::degree(g),
  strength = igraph::strength(
    g,
    vids = igraph::V(g),
    weights = igraph::E(g)$weight
  ),
  betweenness = igraph::betweenness(
    g,
    directed = FALSE,
    normalized = TRUE
  ),
  logFC = igraph::V(g)$logFC,
  adj.P.Val = igraph::V(g)$adj.P.Val
)

mod_DE_info <- nodes_out |>
  dplyr::group_by(module) |>
  dplyr::summarise(
    module_size = dplyr::n(),
    n_DE = sum(
      adj.P.Val < 0.05,
      na.rm = TRUE
    ),
    .groups = "drop"
  )

cat("\nNetwork statistics:\n")
cat("  Total nodes:", igraph::gorder(g), "\n")
cat("  Total edges:", igraph::gsize(g), "\n")
cat("  Seed nodes:", sum(igraph::V(g)$seed), "\n")
cat(
  "  Modules:",
  length(unique(igraph::V(g)$module)),
  "\n"
)
cat(
  "  Density:",
  igraph::edge_density(g),
  "\n"
)
cat(
  "  Transitivity:",
  igraph::transitivity(g),
  "\n"
)
```

## 7. Over-Representation Analysis (ORA)

To biologically interpret the network modules, we perform Reactome over-representation analysis. For each module, the most significantly enriched pathway is used as a representative label. This links graph-based communities to biological processes.

```{r}
reactome_t2g <- msigdbr(
  species = "Homo sapiens",
  category = "C2",
  subcategory = "REACTOME"
) |>
  dplyr::select(
    term = gs_name,
    gene = entrez_gene
  ) |>
  dplyr::distinct()

enrich_module <- function(
  genes_symbol,
  universe_symbol,
  tag,
  mod_id,
  output_dir
) {
  if (length(genes_symbol) < 5) {
    return(invisible(NULL))
  }
  
  sig_m <- tt_gene |>
    dplyr::filter(
      symbol %in% genes_symbol,
      !is.na(entrez)
    )

  uni_m <- tt_gene |>
    dplyr::filter(
      symbol %in% universe_symbol,
      !is.na(entrez)
    )

  gene <- sig_m$entrez
  universe <- uni_m$entrez
  
  clusterProfiler::enricher(
    gene = gene,
    universe = universe,
    TERM2GENE = reactome_t2g,
    pAdjustMethod = "BH",
    qvalueCutoff = 0.05
  )
}

mods <- sort(unique(igraph::V(g)$module))

ora_results <- vector("list", length(mods))
names(ora_results) <- paste0("Module_", mods)

for (i in seq_along(mods)) {
  m <- mods[i]

  mod_genes <- nodes_out$symbol[
    nodes_out$module == m
  ]
  
  res <- enrich_module(
    genes_symbol = mod_genes,
    universe_symbol = universe_symbols,
    tag = tag,
    mod_id = m,
    output_dir = "."
  )
  
  ora_results[[i]] <- res
}

module_enrich_df <- dplyr::bind_rows(
  lapply(
    seq_along(ora_results),
    function(i) {
      res <- ora_results[[i]]

      if (is.null(res)) {
        return(NULL)
      }

      df <- as.data.frame(res)

      if (nrow(df) == 0) {
        return(NULL)
      }

      df$module <- mods[i]
      df
    }
  )
)

module_summary <- module_enrich_df |>
  dplyr::group_by(module) |>
  dplyr::summarise(
    n_sig_pathways = dplyr::n(),
    top_term = ID[which.min(p.adjust)],
    top_q = min(p.adjust),
    .groups = "drop"
  )

module_summary <- module_summary |>
  dplyr::left_join(
    mod_DE_info,
    by = "module"
  ) |>
  dplyr::arrange(top_q)

module_summary <- module_summary |>
  dplyr::mutate(
    module_label = stringr::str_replace_all(
      top_term,
      "^REACTOME_",
      ""
    ),
    module_label = stringr::str_replace_all(
      module_label,
      "_",
      " "
    )
  )

nodes_out <- nodes_out |>
  dplyr::left_join(
    module_summary |>
      dplyr::select(module, module_label),
    by = "module"
  )

key_modules <- module_summary |>
  dplyr::filter(
    n_sig_pathways >= 2,
    top_q < 0.05,
    n_DE >= 3
  ) |>
  dplyr::arrange(top_q)

key_modules |>
  dplyr::select(
    module,
    module_size,
    n_sig_pathways,
    top_q
  )

nodes_out <- nodes_out |>
  dplyr::mutate(
    in_key_module = module %in% key_modules$module
  ) |>
  dplyr::relocate(in_key_module, .after = module)

readr::write_csv(
  key_modules,
  file.path(
    output_dir,
    paste0(tag, "_key_modules_ranked.csv")
  )
)
```

## 8. Extraction of Key Differentially Expressed Genes

From the annotated network, we extract the top 20 upregulated and top 20 downregulated genes. These represent highly differentiated genes in the Tumor vs Normal contrast and are used for summarizing key biological processes in the data.

```{r}
top20_up <- nodes_out |>
  dplyr::filter(
    !is.na(logFC),
    logFC > 0,
    !is.na(adj.P.Val),
    adj.P.Val < 0.05
  ) |>
  dplyr::arrange(dplyr::desc(logFC)) |>
  dplyr::slice_head(n = 20) |>
  dplyr::mutate(direction = "Upregulated")

top20_down <- nodes_out |>
  dplyr::filter(
    !is.na(logFC),
    logFC < 0,
    !is.na(adj.P.Val),
    adj.P.Val < 0.05
  ) |>
  dplyr::arrange(logFC) |>
  dplyr::slice_head(n = 20) |>
  dplyr::mutate(direction = "Downregulated")

combined_40 <- dplyr::bind_rows(
  top20_up,
  top20_down
) |>
  dplyr::arrange(
    dplyr::desc(abs(logFC))
  )

readr::write_csv(
  combined_40,
  file.path(
    output_dir,
    paste0(tag, "_top40_DE.csv")
  )
)
```
